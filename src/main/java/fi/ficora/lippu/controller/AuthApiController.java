package fi.ficora.lippu.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import fi.ficora.lippu.domain.Auth;
import fi.ficora.lippu.domain.Nonce;
import fi.ficora.lippu.domain.model.AccountId;
import fi.ficora.lippu.domain.model.ApiError;
import fi.ficora.lippu.domain.model.AuthenticationInitResponse;
import fi.ficora.lippu.domain.model.AuthenticationRequest;
import fi.ficora.lippu.domain.model.AuthenticationResponse;
import fi.ficora.lippu.exception.AccountNotFoundException;
import fi.ficora.lippu.exception.AuthVerificationFailedException;
import fi.ficora.lippu.service.IAuthService;
import fi.ficora.lippu.util.ConversionUtil;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;

import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.Locale;
import javax.validation.Valid;

import org.jose4j.lang.JoseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.context.MessageSource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;


@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2017-09-11T13:35:10.864+03:00")

@Controller
public class AuthApiController implements AuthApi {
    private final ObjectMapper objectMapper;

    private static final Logger log = LoggerFactory.getLogger(AuthApiController.class);

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private IAuthService authService;

    public AuthApiController(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @ApiOperation(value = "Creates a valid authentication token", nickname = "commitAuth", notes = "", response = AuthenticationResponse.class, tags={ "login", })
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "[JWT](https://jwt.io/) authentication token for making authorized requests.", response = AuthenticationResponse.class),
            @ApiResponse(code = 403, message = "Authentication failed", response = ApiError.class),
            @ApiResponse(code = 405, message = "Input error", response = ApiError.class) })
    @RequestMapping(value = "/auth/commit",
            produces = { "application/json", "application/xml" },
            consumes = { "application/json", "application/xml" },
            method = RequestMethod.POST)
    public ResponseEntity<?> commitAuth(@ApiParam(value = "Unique message identification that is used for error situations. Every client implementation will create its own message ids." ,required=true) @RequestHeader(value="X-Message-Id", required=true) String xMessageId,@ApiParam(value = "Unique transaction identification that is used for error situations. Value is generated by original requestor and used in every message in the whole request chain related to the same ticket transaction." ,required=true) @RequestHeader(value="X-Transaction-Id", required=true) String xTransactionId,@ApiParam(value = "Text indentification of original requestor. Value is use for error situations." ,required=true) @RequestHeader(value="X-Initiator", required=true) String xInitiator,@ApiParam(value = "Input for validating authentication request." ,required=true )  @Valid @RequestBody AuthenticationRequest body, @RequestHeader(value = "Accept", required = false) String accept) throws Exception {
        log.info("Operation: commitAuth; Transaction: {}; Message: {}; Initator: {}",
                xTransactionId,
                xMessageId,
                xInitiator);
        try {

            Auth auth = authService.verifyAuthentication(body.getData(),
                    body.getCnonce(),
                    body.getSnonce(),
                    body.getPubKeyId(), body.getAlg().toString());
            if (auth == null) {
                log.info("Operation: commitAuth; token is null for {}, returning forbidden.",
                        ConversionUtil.sanitizeLog(xInitiator));
                ApiError error = new ApiError();
                error.setStatusCode(BigDecimal.valueOf(403));
                error.setMessage(messageSource.getMessage("http.error.message.403", null, Locale.ENGLISH));
                return new ResponseEntity<ApiError>(error, HttpStatus.FORBIDDEN);
            }
            AuthenticationResponse response = new AuthenticationResponse()
                    .token(auth.getToken())
                    .expires(auth.getExpires())
                    .user(auth.getClientId());
            return new ResponseEntity<AuthenticationResponse>(response, HttpStatus.OK);
        } catch (JoseException | UnsupportedEncodingException |
                AuthVerificationFailedException e) {
            log.info("Operation: commitAuth; exception thrown {}, initator {}," +
                            "returning forbidden.",
                    e.getMessage(), ConversionUtil.sanitizeLog(xInitiator));
            ApiError error = new ApiError();
            error.setStatusCode(BigDecimal.valueOf(403));
            error.setMessage(messageSource.getMessage("http.error.message.403",
                    null, Locale.ENGLISH));
            return new ResponseEntity<ApiError>(error, HttpStatus.FORBIDDEN);
        }
    }

    @ApiOperation(value = "Initiates authentication process", nickname = "initAuth", notes = "", response = AuthenticationInitResponse.class, tags={ "login", })
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Authentication initialization response. Response includes server side nonce value for the authentication process.", response = AuthenticationInitResponse.class),
            @ApiResponse(code = 403, message = "Company account does not exists or valid authentication token could not be generated.", response = ApiError.class),
            @ApiResponse(code = 405, message = "Invalid company account.", response = ApiError.class) })
    @RequestMapping(value = "/auth/init",
            produces = { "application/json", "application/xml" },
            consumes = { "application/json", "application/xml" },
            method = RequestMethod.POST)
    public ResponseEntity<?> initAuth(@ApiParam(value = "Unique message identification that is used for error situations. Every client implementation will create its own message ids." ,required=true) @RequestHeader(value="X-Message-Id", required=true) String xMessageId,@ApiParam(value = "Unique transaction identification that is used for error situations. Value is generated by original requestor and used in every message in the whole request chain related to the same ticket transaction." ,required=true) @RequestHeader(value="X-Transaction-Id", required=true) String xTransactionId,@ApiParam(value = "Text indentification of original requestor. Value is use for error situations." ,required=true) @RequestHeader(value="X-Initiator", required=true) String xInitiator,@ApiParam(value = "Company account identification" ,required=true )  @Valid @RequestBody AccountId body, @RequestHeader(value = "Accept", required = false) String accept) throws Exception {
        if(body.getAccount() != null ) {
            try {
                Nonce nonce = authService.generateNonce(body.getAccount());
                if (nonce != null) {
                    AuthenticationInitResponse response = new AuthenticationInitResponse()
                            .nonce(nonce.getNonce())
                            .user(nonce.getClient())
                            .expires(OffsetDateTime.of(nonce.getExp(), OffsetDateTime.now().getOffset()));

                    return new ResponseEntity<AuthenticationInitResponse>(response, HttpStatus.OK);
                }
            } catch (AccountNotFoundException e) {
                ApiError error =  new ApiError();
                error.setStatusCode(BigDecimal.valueOf(403));
                error.setMessage(messageSource.getMessage("http.error.message.403",null, Locale.ENGLISH));
                return new ResponseEntity<ApiError>(error, HttpStatus.FORBIDDEN);
            }
        }
        ApiError error =  new ApiError();
        error.setStatusCode(BigDecimal.valueOf(403));
        error.setMessage(messageSource.getMessage("http.error.message.403",null, Locale.ENGLISH));
        return new ResponseEntity<ApiError>(error, HttpStatus.FORBIDDEN);

    }

}
