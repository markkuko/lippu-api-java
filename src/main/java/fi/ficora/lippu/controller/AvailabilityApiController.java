package fi.ficora.lippu.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import fi.ficora.lippu.domain.Product;
import fi.ficora.lippu.domain.Reservation;
import fi.ficora.lippu.domain.ReservationItem;
import fi.ficora.lippu.domain.model.*;
import fi.ficora.lippu.service.IAuthService;
import fi.ficora.lippu.service.IAvailabilityService;
import fi.ficora.lippu.service.ITimetableService;
import fi.ficora.lippu.service.IProductService;
import fi.ficora.lippu.util.ApiErrorUtil;
import fi.ficora.lippu.util.ConversionUtil;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import javax.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;

import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;



@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2017-09-11T13:35:10.864+03:00")

@Controller
public class AvailabilityApiController implements AvailabilityApi {
    private final ObjectMapper objectMapper;

    @Autowired
    private IAuthService authService;

    @Autowired
    private IAvailabilityService availabilityService;

    @Autowired
    private ITimetableService timetableService;

    @Autowired
    private MessageSource messageSource;
    @Autowired
    private IProductService productService;
    private static final Logger log = LoggerFactory.getLogger(AvailabilityApiController.class);

    public AvailabilityApiController(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @ApiOperation(value = "Trip availaibility inquiry", notes = "API to inquire trip availabilities from transport operator.", response = AvailabilityResponse.class, tags={ "availability", })
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Returns free transport service capability with given search terms.", response = AvailabilityResponse.class) })
    @RequestMapping(value = "/availability",
            produces = { "application/json", "application/xml" },
            consumes = { "application/json", "application/xml" },
            method = RequestMethod.POST)
    public ResponseEntity<?> availability(@ApiParam(value = "Unique message identification that is used for error situations. Every client implementation will add its own message ids." ,required=true) @RequestHeader(value="X-Message-Id", required=true) String xMessageId, @ApiParam(value = "Unique transaction identification that is used for error situations. Value is generated by original requestor and used in every message related to same ticket transaction." ,required=true) @RequestHeader(value="X-Transaction-Id", required=true) String xTransactionId, @ApiParam(value = "Text indentification of original requestor. Value is use for error situations." ,required=true) @RequestHeader(value="X-Initiator", required=true) String xInitiator, @ApiParam(value = "Language value like specified in [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4). Value is used to localize response values." ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage, @ApiParam(value = "[JWT](https://jwt.io/) authentication token for authorization requests." ,required=true) @RequestHeader(value="X-Authorization", required=true) String authorization, @ApiParam(value = "Availability search terms" ,required=true )  @Valid @RequestBody AvailabilityRequest body, @RequestHeader(value = "Accept", required = false) String accept) throws Exception {
        log.info("Operation: commitAuth; Transaction: {}; Message: {}; Initator: {}",
                xTransactionId,
                xMessageId,
                xInitiator);
        AvailabilityResponse response = new AvailabilityResponse();
        if(!validateCoordinates(body)) {
            return new ResponseEntity<ApiError>(ApiErrorUtil.generateApiError400(
                    messageSource.getMessage("http.error.message.400.elements",
                            null, Locale.ENGLISH)), HttpStatus.BAD_REQUEST);
        }
        Product product = productService.getProduct(body.getTravel(), body.getContract());
        if(product != null) {
            Reservation reservation = availabilityService.checkForCapacity(product,
                body.getTravel().getDateTime().toLocalDate(), body.getPassengers());
            if(reservation != null) {
                Travel travel = body.getTravel();
                travel.setDateTime(timetableService.getProductDeparture(travel.getDateTime().toLocalDate(),
                        product));
                response.setTravel(body.getTravel());
                response.setContract(product.getContract());

                for (TravelPassenger passenger : body.getPassengers()) {
                    TravelAvailability item = availabilityService.addAvailability(
                            reservation,product, passenger, body.getTravel());
                    if(item != null) {
                        response.addAvailabilityItem(item );
                    } else {
                        log.debug("Got null for availabity add");
                    }
                }
                return new ResponseEntity<AvailabilityResponse>(response, HttpStatus.OK);
            } else {
                log.debug("Got null for capacity check.");
                response.setTravel(body.getTravel());
                response.setContract(body.getContract());
                return new ResponseEntity<AvailabilityResponse>(response, HttpStatus.OK);
            }
        } else {
            log.debug("Product not found, returning 400");
            return new ResponseEntity<ApiError>(ApiErrorUtil.generateApiError400(
                    messageSource.getMessage("http.error.message.400.productnotfound",
                            null, Locale.ENGLISH)), HttpStatus.BAD_REQUEST);
        }
    }

    private boolean validateCoordinates(AvailabilityRequest body) {
        if(body.getTravel().getFrom().getLat() == null ||
                body.getTravel().getFrom().getLon() == null ||
                body.getTravel().getFrom().getLat() == null ||
                body.getTravel().getTo().getLon() == null) {
            return false;
        } else {
            return true;
        }

    }

}
