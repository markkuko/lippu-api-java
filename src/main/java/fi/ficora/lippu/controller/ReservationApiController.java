package fi.ficora.lippu.controller;

import fi.ficora.lippu.config.Constants;
import fi.ficora.lippu.domain.Reservation;
import fi.ficora.lippu.domain.ReservationItem;
import fi.ficora.lippu.domain.model.*;
import fi.ficora.lippu.service.ReservationService;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import javax.validation.Valid;
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2017-09-11T13:35:10.864+03:00")

@Controller
public class ReservationApiController implements ReservationApi {
    private final ObjectMapper objectMapper;

    @Autowired
    private ReservationService reservationService;
    public ReservationApiController(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @ApiOperation(value = "Travel reservation", notes = "An interface that allows operators to make travel reservations from a transport service.", response = ReservationResponse.class, tags={ "reservation", })
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Returns the ticket-payloads generated by the transport service and the corresponding booking data.", response = ReservationResponse.class) })
    @RequestMapping(value = "/reservation",
            produces = { "application/json", "application/xml" },
            consumes = { "application/json", "application/xml" },
            method = RequestMethod.POST)
    public  ResponseEntity<ReservationResponse> reservation(@ApiParam(value = "Unique message identification that is used for error situations. Every client implementation will add its own message ids." ,required=true) @RequestHeader(value="X-Message-Id", required=true) String xMessageId, @ApiParam(value = "Unique transaction identification that is used for error situations. Value is generated by original requestor and used in every message related to same ticket transaction." ,required=true) @RequestHeader(value="X-Transaction-Id", required=true) String xTransactionId, @ApiParam(value = "Text indentification of original requestor. Value is use for error situations." ,required=true) @RequestHeader(value="X-Initiator", required=true) String xInitiator, @ApiParam(value = "Language value like specified in [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4). Value is used to localize response values." ,required=true) @RequestHeader(value="Accept-Language", required=true) String acceptLanguage, @ApiParam(value = "[JWT](https://jwt.io/) authentication token for authorization requests." ,required=true) @RequestHeader(value="X-Authorization", required=true) String authorization, @ApiParam(value = "Reservation information" ,required=true )  @Valid @RequestBody ReservationRequest body, @RequestHeader(value = "Accept", required = false) String accept) throws Exception {
        Reservation reservation = reservationService.add(body);
        if(reservation != null) {
            ReservationResponse response = new ReservationResponse();
            List<ReservationResponseConfirmedReservations> confirmedReservations =
                    new ArrayList<ReservationResponseConfirmedReservations>();
            for(ReservationItem item: reservation.getReservationItems()) {
                ReservationResponseConfirmedReservations confirmedReservation = new
                        ReservationResponseConfirmedReservations();
                confirmedReservation.setReservationData(item.getReservationData());
                confirmedReservation.setTicketPayload(item.getTicketPayload());
                confirmedReservation.setValidFrom(item.getValidFrom());
                confirmedReservation.setValidTo(item.getValidTo());
                response.addConfirmedReservationsItem(confirmedReservation);
            }

            response.setCaseId(reservation.getCaseId());
            return new ResponseEntity<ReservationResponse>(response, HttpStatus.OK);
        } else {
            return new ResponseEntity<ReservationResponse>(HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Cancelletion of transport reservation", notes = "", response = Boolean.class, tags={ "reservation", })
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Returns an acknowledgment of a successful cancellation", response = Boolean.class),
            @ApiResponse(code = 404, message = "No valid booking with given case identifier.") })
    @RequestMapping(value = "/reservation/{caseId}",
            produces = { "application/json", "application/xml" },
            consumes = { "application/json", "application/xml" },
            method = RequestMethod.DELETE)
    public ResponseEntity<?> reservationDelete(@ApiParam(value = "Unique message identification that is used for error situations. Every client implementation will add its own message ids." ,required=true) @RequestHeader(value="X-Message-Id", required=true) String xMessageId, @ApiParam(value = "Unique transaction identification that is used for error situations. Value is generated by original requestor and used in every message related to same ticket transaction." ,required=true) @RequestHeader(value="X-Transaction-Id", required=true) String xTransactionId, @ApiParam(value = "Text indentification of original requestor. Value is use for error situations." ,required=true) @RequestHeader(value="X-Initiator", required=true) String xInitiator, @ApiParam(value = "[JWT](https://jwt.io/) authentication token for authorization requests." ,required=true) @RequestHeader(value="X-Authorization", required=true) String authorization, @ApiParam(value = "A case identifier for a reservation that will be removed",required=true ) @PathVariable("caseId") String caseId, @RequestHeader(value = "Accept", required = false) String accept) throws Exception {
        int response = reservationService.delete(caseId);
        if(response == Constants.RESULTCODE_SUCCESS) {
            ReservationDeleteResponse deleteResponse= new ReservationDeleteResponse();
            deleteResponse.cancellation(Boolean.TRUE);
            return new ResponseEntity<ReservationDeleteResponse>(deleteResponse, HttpStatus.OK);
        } else if(response == Constants.RESULTCODE_FORBIDDEN){
            ApiError error = new ApiError();
            error.setStatusCode(new BigDecimal(403));
            error.setMessage("Forbidden to access the resource");
            return new ResponseEntity<ApiError>(error, HttpStatus.FORBIDDEN);
        } else {
            ApiError error = new ApiError();
            error.setStatusCode(new BigDecimal(404));
            error.setMessage("Resource not found.");
            return new ResponseEntity<ApiError>(error, HttpStatus.NOT_FOUND);
        }
    }
}
